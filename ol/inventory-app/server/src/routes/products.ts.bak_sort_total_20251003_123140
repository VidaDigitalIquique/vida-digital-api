import { Router } from "express";
import { getPool } from "../lib/sql";
import { DATA_SOURCES } from "../config/data-sources";

const router = Router();
const pool = getPool();

function safeIdent(id: string | null | undefined): string | null {
  if (!id) return null;
  return /^[a-zA-Z0-9_]+$/.test(id) ? id : null;
}

type ResolvedTable = { schema: string | null; table: string };

async function resolveTable(table: string, preferredSchema?: string): Promise<ResolvedTable> {
  if (preferredSchema) {
    const r = await pool.query(
      "SELECT 1 FROM information_schema.tables WHERE table_schema = $1 AND table_name = $2",
      [preferredSchema, table]
    );
    if (r.rowCount > 0) return { schema: preferredSchema, table };
  }
  const sql =
    "SELECT table_schema, table_name\n" +
    "FROM information_schema.tables\n" +
    "WHERE lower(table_name) = lower($1)\n" +
    "  AND table_type = 'BASE TABLE'\n" +
    "  AND table_schema NOT IN ('pg_catalog','information_schema')\n" +
    "ORDER BY CASE WHEN table_schema='public' THEN 0 ELSE 1 END, table_schema\n" +
    "LIMIT 1";
  const { rows } = await pool.query(sql, [table]);
  if (rows.length === 0) return { schema: null, table };
  return { schema: String(rows[0].table_schema), table: String(rows[0].table_name) };
}

// GET /products?q=SF&limit=20&offset=0
router.get("/products", async (req, res) => {
  try {
    const q = String(req.query.q ?? "").trim();
    const limit = Math.min(parseInt(String(req.query.limit ?? "20"), 10) || 20, 200);
    const offset = Math.max(parseInt(String(req.query.offset ?? "0"), 10) || 0, 0);

    const prod: any = (DATA_SOURCES as any).producto;
    const inv: any = (DATA_SOURCES as any).inventar;

    const pResolved = await resolveTable(prod.table, prod.schema);
    const iResolved = await resolveTable(inv.table, inv.schema);

    if (!pResolved.schema) return res.status(404).json({ error: "Tabla " + prod.table + " no encontrada" });
    if (!iResolved.schema) return res.status(404).json({ error: "Tabla " + inv.table + " no encontrada" });

    const pCode = safeIdent(prod.code);
    const pDesc = safeIdent(prod.description);
    const iCode = safeIdent(inv.code);
    const iStockUnits = safeIdent(inv.stock_units);
    const iStockBoxes = safeIdent(inv.stock_boxes);
    const iQtyPerBox = safeIdent("cantcaja");
    const iCostUsd = safeIdent("cosunita");

    if (!pCode) return res.status(500).json({ error: "No se detectÃ³ columna de cÃ³digo en producto" });
    if (!iCode) return res.status(500).json({ error: "No se detectÃ³ columna de cÃ³digo en inventar" });

    const pSelectCols =
      'p."' + pCode + '" as code, ' +
      (pDesc ? 'p."' + pDesc + '" as description' : 'NULL::text as description');

    const iSelectCols = [
      'i."' + iCode + '" as code',
      iStockUnits ? 'i."' + iStockUnits + '"::numeric as stock_units' : 'NULL::numeric as stock_units',
      iStockBoxes ? 'i."' + iStockBoxes + '"::numeric as stock_boxes' : 'NULL::numeric as stock_boxes',
      iQtyPerBox ? 'i."' + iQtyPerBox + '"::numeric as qty_per_box' : 'NULL::numeric as qty_per_box',
      iCostUsd ? 'i."' + iCostUsd + '"::numeric as cost_usd' : 'NULL::numeric as cost_usd',
    ].join(", ");

    let where = "";
    const params: any[] = [];
    if (q && pDesc) {
      params.push("%" + q + "%");
      params.push("%" + q + "%");
      where = 'WHERE p."' + pCode + '" ILIKE $1 OR p."' + pDesc + '" ILIKE $2';
    } else if (q) {
      params.push("%" + q + "%");
      where = 'WHERE p."' + pCode + '" ILIKE $1';
    }

    params.push(limit);
    params.push(offset);
    const limitIdx = params.length - 1;
    const offsetIdx = params.length;

    const finalCols = [
      "pd.code",
      "pd.description",
      "id.stock_units",
      "id.stock_boxes",
      "id.cost_usd",
      "id.qty_per_box",
      "CASE WHEN id.qty_per_box IS NOT NULL AND id.qty_per_box > 0 THEN (id.stock_units / id.qty_per_box) ELSE NULL END AS inventory_boxes",
      "NULL::numeric as physical_boxes",
      "NULL::numeric as difference_boxes",
    ].join(", ");

    const sql =
      "WITH psrc AS (\n" +
      "  SELECT " + pSelectCols + "\n" +
      '  FROM "' + pResolved.schema + '"."' + pResolved.table + '" p\n' +      // â† corregido (sin comilla extra)
      (where ? "  " + where + "\n" : "") +
      "),\n" +
      "p_dedup AS (\n" +
      "  SELECT * FROM (\n" +
      "    SELECT psrc.*, ROW_NUMBER() OVER (PARTITION BY code ORDER BY code) AS rn\n" +
      "    FROM psrc\n" +
      "  ) t WHERE rn = 1\n" +
      "),\n" +
      "isrc AS (\n" +
      "  SELECT " + iSelectCols + "\n" +
      '  FROM "' + iResolved.schema + '"."' + iResolved.table + '" i\n' +
      "),\n" +
      "i_dedup AS (\n" +
      "  SELECT * FROM (\n" +
      "    SELECT isrc.*, ROW_NUMBER() OVER (PARTITION BY code ORDER BY code) AS rn\n" +
      "    FROM isrc\n" +
      "  ) t WHERE rn = 1\n" +
      ")\n" +
      "SELECT " + finalCols + "\n" +
      "FROM p_dedup pd\n" +
      "LEFT JOIN i_dedup id ON id.code = pd.code\n" +
      "ORDER BY pd.code ASC\n" +
      "LIMIT $" + String(limitIdx) + " OFFSET $" + String(offsetIdx);

    const { rows } = await pool.query(sql, params);

    const markup = Number(process.env.PRICE_MARKUP ?? "0");
    const out = rows.map((r: any) => {
      const cost = r.cost_usd != null ? Number(r.cost_usd) : null;
      const price =
        cost != null && Number.isFinite(cost)
          ? (cost * (1 + (Number.isFinite(markup) ? markup : 0))).toFixed(2)
          : null;
      return { ...r, price_usd: price };
    });

    res.json({ rows: out, count: out.length });
  } catch (e: any) {
    res.status(500).json({ error: e.message || "products error" });
  }
});


router.get("/products/:code", async (req, res) => {
  try {
    const codeParam = String(req.params.code ?? "").trim();
    if (!codeParam) return res.status(400).json({ error: "code is required" });

    const prod = (DATA_SOURCES as any).producto;
    const inv = (DATA_SOURCES as any).inventar;

    const pResolved = await resolveTable(prod.table, prod.schema);
    const iResolved = await resolveTable(inv.table, inv.schema);

    if (!pResolved.schema) return res.status(404).json({ error: "Tabla " + prod.table + " no encontrada" });
    if (!iResolved.schema) return res.status(404).json({ error: "Tabla " + inv.table + " no encontrada" });

    const pCode = safeIdent(prod.code);
    const pDesc = safeIdent(prod.description);
    const iCode = safeIdent(inv.code);
    const iStockUnits = safeIdent(inv.stock_units);
    const iStockBoxes = safeIdent(inv.stock_boxes);
    const iQtyPerBox = safeIdent("cantcaja");
    const iCostUsd = safeIdent("cosunita");

    if (!pCode) return res.status(500).json({ error: "No se detectó columna de código en producto" });
    if (!iCode) return res.status(500).json({ error: "No se detectó columna de código en inventar" });

    const pSelectCols =
      'p."' + pCode + '" as code, ' +
      (pDesc ? 'p."' + pDesc + '" as description' : 'NULL::text as description');

    const iSelectCols = [
      'i."' + iCode + '" as code',
      iStockUnits ? 'i."' + iStockUnits + '"::numeric as stock_units' : 'NULL::numeric as stock_units',
      iStockBoxes ? 'i."' + iStockBoxes + '"::numeric as stock_boxes' : 'NULL::numeric as stock_boxes',
      iQtyPerBox ? 'i."' + iQtyPerBox + '"::numeric as qty_per_box' : 'NULL::numeric as qty_per_box',
      iCostUsd ? 'i."' + iCostUsd + '"::numeric as cost_usd' : 'NULL::numeric as cost_usd',
    ].join(", ");

    const finalCols = [
      "pd.code",
      "pd.description",
      "id.stock_units",
      "id.stock_boxes",
      "id.cost_usd",
      "id.qty_per_box",
      "CASE WHEN id.qty_per_box IS NOT NULL AND id.qty_per_box > 0 THEN (id.stock_units / id.qty_per_box) ELSE NULL END AS inventory_boxes",
      "NULL::numeric as physical_boxes",
      "NULL::numeric as difference_boxes",
    ].join(", ");

    const sql =
      "WITH psrc AS (\n" +
      "  SELECT " + pSelectCols + "\n" +
      '  FROM "' + pResolved.schema + '"."' + pResolved.table + '" p\n' +
      '  WHERE p."' + pCode + '" = $1\n' +
      "),\n" +
      "ps AS (\n" +
      "  SELECT * FROM psrc\n" +
      "),\n" +
      "isrc AS (\n" +
      "  SELECT " + iSelectCols + "\n" +
      '  FROM "' + iResolved.schema + '"."' + iResolved.table + '" i\n' +
      "),\n" +
      "i_dedup AS (\n" +
      "  SELECT * FROM (\n" +
      "    SELECT isrc.*, ROW_NUMBER() OVER (PARTITION BY code ORDER BY code) AS rn\n" +
      "    FROM isrc\n" +
      "  ) t WHERE rn = 1\n" +
      ")\n" +
      "SELECT " + finalCols + "\n" +
      "FROM ps pd\n" +
      "LEFT JOIN i_dedup id ON id.code = pd.code\n" +
      "LIMIT 1";

    const { rows } = await pool.query(sql, [codeParam]);

    const markup = Number(process.env.PRICE_MARKUP ?? "0");
    const out = rows.map((r: any) => {
      const cost = r.cost_usd != null ? Number(r.cost_usd) : null;
      const price =
        cost != null && Number.isFinite(cost)
          ? (cost * (1 + (Number.isFinite(markup) ? markup : 0))).toFixed(2)
          : null;
      return { ...r, price_usd: price };
    });

    res.json(out[0] ?? null);
  } catch (e: any) {
    res.status(500).json({ error: e.message || "product detail error" });
  }
});
export default router;