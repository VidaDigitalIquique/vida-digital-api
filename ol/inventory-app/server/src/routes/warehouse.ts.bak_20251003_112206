import { Router } from "express";
import crypto from "crypto";
import { getPool } from "../lib/sql";
import { DATA_SOURCES } from "../config/data-sources";

const router = Router();
const pool = getPool();

function isNonEmpty(v: any): v is string {
  return typeof v === "string" && v.trim().length > 0;
}
function isLocationCode(v: any): v is string {
  return typeof v === "string" && /^[A-Za-z0-9_-]+$/.test(String(v));
}
function safeIdent(id: string | null | undefined): string | null {
  if (!id) return null;
  return /^[a-zA-Z0-9_]+$/.test(id) ? id : null;
}

async function findColumn(table: string, names: string[], schema = "public"): Promise<string | null> {
  const { rows } = await pool.query(
    `SELECT column_name
       FROM information_schema.columns
      WHERE table_schema = $1 AND table_name = $2`,
    [schema, table]
  );
  const cols = rows.map((r: any) => String(r.column_name));
  for (const n of names) {
    const hit = cols.find(c => c.toLowerCase() === n.toLowerCase());
    if (hit) return `"${hit}"`;
  }
  return null;
}

type ResolvedTable = { schema: string | null; table: string };

async function resolveTable(table: string, preferredSchema?: string): Promise<ResolvedTable> {
  if (preferredSchema) {
    const r = await pool.query(
      "SELECT 1 FROM information_schema.tables WHERE table_schema = $1 AND table_name = $2",
      [preferredSchema, table]
    );
    if (r.rowCount > 0) return { schema: preferredSchema, table };
  }
  const sql =
    "SELECT table_schema, table_name " +
    "FROM information_schema.tables " +
    "WHERE lower(table_name) = lower($1) " +
    "  AND table_type = 'BASE TABLE' " +
    "  AND table_schema NOT IN ('pg_catalog','information_schema') " +
    "ORDER BY CASE WHEN table_schema='public' THEN 0 ELSE 1 END, table_schema " +
    "LIMIT 1";
  const { rows } = await pool.query(sql, [table]);
  if (rows.length === 0) return { schema: null, table };
  return { schema: String(rows[0].table_schema), table: String(rows[0].table_name) };
}

/** ========== LOCATIONS ========== **/
router.get("/locations", async (_req, res) => {
  try {
    const createdAtCol = await findColumn("app_location", ["createdAt", "createdat"]);
    const updatedAtCol = await findColumn("app_location", ["updatedAt", "updatedat"]);

    const selectCols =
      'id, code, name, notes' +
      (createdAtCol ? `, ${createdAtCol} AS "createdAt"` : '') +
      (updatedAtCol ? `, ${updatedAtCol} AS "updatedAt"` : '');

    const { rows } = await pool.query(
      `SELECT ${selectCols} FROM app_location ORDER BY code ASC`
    );
    res.json(rows);
  } catch (e: any) {
    res.status(500).json({ error: e.message || "locations error" });
  }
});

router.post("/locations", async (req, res) => {
  try {
    const code = String(req.body?.code ?? "").trim();
    const name = req.body?.name ? String(req.body.name) : null;
    const notes = req.body?.notes ? String(req.body.notes) : null;
    if (!isLocationCode(code)) return res.status(400).json({ error: "code invÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¡lido" });

    const createdAtCol = await findColumn("app_location", ["createdAt", "createdat"]);
    const updatedAtCol = await findColumn("app_location", ["updatedAt", "updatedat"]);
    const id = crypto.randomUUID();

    const insertCols: string[] = ['id','code','name','notes'];
    const insertVals: string[] = ['$1','$2','$3','$4'];
    if (createdAtCol) { insertCols.push(createdAtCol); insertVals.push('now()'); }
    if (updatedAtCol) { insertCols.push(updatedAtCol); insertVals.push('now()'); }

    const baseInsert =
      `INSERT INTO app_location (${insertCols.join(', ')}) VALUES (${insertVals.join(', ')})
       ON CONFLICT (code) DO UPDATE SET name = EXCLUDED.name, notes = EXCLUDED.notes`;
    const withUpdated = updatedAtCol ? baseInsert + `, ${updatedAtCol} = now()` : baseInsert;

    const returningCols =
      'id, code, name, notes' +
      (createdAtCol ? `, ${createdAtCol} AS "createdAt"` : '') +
      (updatedAtCol ? `, ${updatedAtCol} AS "updatedAt"` : '');

    const sql = withUpdated + ` RETURNING ${returningCols}`;
    const { rows } = await pool.query(sql, [id, code, name, notes]);

    // audit tolerante
    try {
      await pool.query(
        `INSERT INTO app_audit_log (id, "actorUserId", action, entity, "entityId", diff, "createdAt")
         VALUES ($1,$2,$3,$4,$5,$6, now())`,
        [crypto.randomUUID(), 'system', 'UPSERT_LOCATION', 'app_location', rows[0].id, { code, name, notes }]
      );
    } catch {}

    res.json(rows[0]);
  } catch (e: any) {
    res.status(500).json({ error: e.message || "locations upsert error" });
  }
});

/** ========== COUNTS ========== **/
router.get("/counts", async (req, res) => {
  try {
    const code = String(req.query.code ?? "").trim();
    if (!isNonEmpty(code)) return res.status(400).json({ error: "code requerido" });

    const colProductCode = (await findColumn("app_physical_count", ["productCode","productcode"])) ?? `"productCode"`;
    const colCountedAt   = await findColumn("app_physical_count", ["countedAt","countedat"]);
    const colCountedBoxes = (await findColumn("app_physical_count", ["countedBoxes","countedboxes"])) ?? `"countedBoxes"`;
    const countedAtSelect = colCountedAt ? `${colCountedAt} AS "countedAt"` : `NULL::timestamp AS "countedAt"`;

    const sql =
      `WITH latest AS (
         SELECT c.*, ROW_NUMBER() OVER (PARTITION BY c.location_id ORDER BY ${colCountedAt ?? 'id'} DESC) rn
           FROM app_physical_count c
          WHERE ${colProductCode} = $1
       )
       SELECT loc.id AS location_id,
              loc.code AS location_code,
              loc.name AS location_name,
              l.${colCountedBoxes} AS "countedBoxes",
              ${countedAtSelect},
              l.note
         FROM app_location loc
    LEFT JOIN latest l ON l.location_id = loc.id AND l.rn = 1
     ORDER BY loc.code ASC`;

    const { rows } = await pool.query(sql, [code]);
    res.json(rows);
  } catch (e: any) {
    res.status(500).json({ error: e.message || "counts error" });
  }
});

router.post("/counts", async (req, res) => {
  try {
    const productCode = String(req.body?.productCode ?? "").trim();
    const locationCode = String(req.body?.locationCode ?? "").trim();
    const countedBoxesNum = Number(req.body?.countedBoxes);
    const note = req.body?.note ? String(req.body.note) : null;

    if (!isNonEmpty(productCode)) return res.status(400).json({ error: "productCode requerido" });
    if (!isLocationCode(locationCode)) return res.status(400).json({ error: "locationCode invÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¡lido" });
    if (!Number.isFinite(countedBoxesNum)) return res.status(400).json({ error: "countedBoxes invÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¡lido" });

    const colProductCode = (await findColumn("app_physical_count", ["productCode","productcode"])) ?? `"productCode"`;
    const colCountedBoxes = (await findColumn("app_physical_count", ["countedBoxes","countedboxes"])) ?? `"countedBoxes"`;
    const colCountedAt   = (await findColumn("app_physical_count", ["countedAt","countedat"])) ?? `"countedAt"`;

    let loc = await pool.query('SELECT id FROM app_location WHERE code = $1', [locationCode]);
    if (loc.rowCount === 0) {
      const newId = crypto.randomUUID();
      const createdAtCol = await findColumn("app_location", ["createdAt", "createdat"]);
      const updatedAtCol = await findColumn("app_location", ["updatedAt", "updatedat"]);
      const baseCols: string[] = ['id','code'];
      const baseVals: string[] = ['$1','$2'];
      if (createdAtCol) { baseCols.push(createdAtCol); baseVals.push('now()'); }
      if (updatedAtCol) { baseCols.push(updatedAtCol); baseVals.push('now()'); }
      await pool.query(
        `INSERT INTO app_location (${baseCols.join(', ')}) VALUES (${baseVals.join(', ')})
         ON CONFLICT (code) DO NOTHING`,
        [newId, locationCode]
      );
      loc = await pool.query('SELECT id FROM app_location WHERE code = $1', [locationCode]);
    }
    const location_id = String(loc.rows[0].id);
    const id = crypto.randomUUID();

    const sql =
      `INSERT INTO app_physical_count (id, ${colProductCode}, location_id, ${colCountedBoxes}, ${colCountedAt}, note)
       VALUES ($1,$2,$3,$4, now(), $5)`;
    await pool.query(sql, [id, productCode, location_id, countedBoxesNum, note]);

    try {
      await pool.query(
        `INSERT INTO app_audit_log (id, "actorUserId", action, entity, "entityId", diff, "createdAt")
         VALUES ($1,$2,$3,$4,$5,$6, now())`,
        [crypto.randomUUID(), 'system', 'CREATE_COUNT', 'app_physical_count', id, { productCode, locationCode, countedBoxes: countedBoxesNum, note }]
      );
    } catch {}

    res.json({ ok: true, id, productCode, locationCode, countedBoxes: countedBoxesNum, note });
  } catch (e: any) {
    res.status(500).json({ error: e.message || "create count error" });
  }
});

router.put("/counts/:id", async (req, res) => {
  try {
    const id = String(req.params.id ?? "").trim();
    const countedBoxesNum = Number(req.body?.countedBoxes);
    const note = req.body?.note != null ? String(req.body.note) : null;
    if (!isNonEmpty(id)) return res.status(400).json({ error: "id requerido" });
    if (!Number.isFinite(countedBoxesNum)) return res.status(400).json({ error: "countedBoxes invÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¡lido" });

    const colCountedBoxes = (await findColumn("app_physical_count", ["countedBoxes","countedboxes"])) ?? `"countedBoxes"`;
    const colCountedAt   = (await findColumn("app_physical_count", ["countedAt","countedat"])) ?? `"countedAt"`;

    const oldR = await pool.query('SELECT * FROM app_physical_count WHERE id = $1', [id]);
    await pool.query(
      `UPDATE app_physical_count
          SET ${colCountedBoxes} = $2, ${colCountedAt} = now(), note = $3
        WHERE id = $1`,
      [id, countedBoxesNum, note]
    );

    try {
      await pool.query(
        `INSERT INTO app_audit_log (id, "actorUserId", action, entity, "entityId", diff, "createdAt")
         VALUES ($1,$2,$3,$4,$5,$6, now())`,
        [crypto.randomUUID(), 'system', 'UPDATE_COUNT', 'app_physical_count', id, { old: oldR.rows[0], new: { id, countedBoxes: countedBoxesNum, note } }]
      );
    } catch {}

    res.json({ ok: true, id });
  } catch (e: any) {
    res.status(500).json({ error: e.message || "update count error" });
  }
});

router.delete("/counts/:id", async (req, res) => {
  try {
    const id = String(req.params.id ?? "").trim();
    if (!isNonEmpty(id)) return res.status(400).json({ error: "id requerido" });
    const oldR = await pool.query('SELECT * FROM app_physical_count WHERE id = $1', [id]);
    await pool.query('DELETE FROM app_physical_count WHERE id = $1', [id]);

    try {
      await pool.query(
        `INSERT INTO app_audit_log (id, "actorUserId", action, entity, "entityId", diff, "createdAt")
         VALUES ($1,$2,$3,$4,$5,$6, now())`,
        [crypto.randomUUID(), 'system', 'DELETE_COUNT', 'app_physical_count', id, { old: oldR.rows[0] }]
      );
    } catch {}

    res.json({ ok: true, id });
  } catch (e: any) {
    res.status(500).json({ error: e.message || "delete count error" });
  }
});

/** ========== AUDIT ========== **/
router.get("/audit", async (req, res) => {
  try {
    const limit = Math.min(parseInt(String(req.query.limit ?? "50"), 10) || 50, 200);
    const { rows } = await pool.query(
      `SELECT id, "actorUserId", action, entity, "entityId", diff, "createdAt"
         FROM app_audit_log
        ORDER BY "createdAt" DESC
        LIMIT $1`,
      [limit]
    );
    res.json(rows);
  } catch (e: any) {
    res.status(500).json({ error: e.message || "audit error" });
  }
});

/** ========== SUMMARY (teÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â³rico vs fÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â­sico) ========== **/
router.get("/summary", async (req, res) => {
  try {
    const productCode = String(req.query.productCode ?? "").trim();
    if (!productCode) return res.status(400).json({ error: "productCode requerido" });

    // 1) Físico: suma de cajas contadas
    const physSql = `
      SELECT COALESCE(SUM(c."countedBoxes"), 0)::numeric AS physical_boxes
      FROM app_physical_count c
      WHERE c."productCode" = $1
    `;
    const phys = await pool.query(physSql, [productCode]);
    const physical_boxes = Number(phys.rows[0]?.physical_boxes ?? 0);

    // 2) Teórico: stock_units / qty_per_box desde sanjh.inventar
    // (ajusta si tu esquema NO es 'sanjh', pero según introspección actual es correcto)
    const invSql = `
      SELECT
        i."stocdisp"::numeric AS stock_units,
        NULLIF(i."cantcaja", '0')::numeric AS qty_per_box
      FROM "sanjh"."inventar" i
      WHERE i."codunico" = $1
      LIMIT 1
    `;
    const inv = await pool.query(invSql, [productCode]);
    const stock_units = Number(inv.rows[0]?.stock_units ?? 0);
    const qty_per_box = Number(inv.rows[0]?.qty_per_box ?? 0);

    const inventory_boxes =
      Number.isFinite(stock_units) && Number.isFinite(qty_per_box) && qty_per_box > 0
        ? stock_units / qty_per_box
        : 0;

    // 3) Diferencias
    const difference_boxes = physical_boxes - inventory_boxes;
    const difference_percent =
      inventory_boxes > 0 ? (difference_boxes / inventory_boxes) * 100 : 0;

    res.json({
      productCode,
      inventory_boxes: Number(inventory_boxes.toFixed(4)),
      physical_boxes: Number(physical_boxes.toFixed(4)),
      difference_boxes: Number(difference_boxes.toFixed(4)),
      difference_percent: Number(difference_percent.toFixed(2)),
    });
  } catch (e: any) {
    res.status(500).json({ error: e.message || "summary error" });
  }
});const q = (s: string) => `"${s.replace(/"/g, '""')}"`; // quote identificadores
    async function findColumnName(table: string, names: string[]): Promise<string | null> {
      const { rows } = await pool.query(
        "SELECT column_name FROM information_schema.columns WHERE table_schema = 'public' AND table_name = $1",
        [table]
      );
      const cols = rows.map((r: any) => String(r.column_name));
      for (const n of names) {
        const hit = cols.find(c => c.toLowerCase() === n.toLowerCase());
        if (hit) return hit; // sin comillas
      }
      return null;
    }

    // --- Inventario teÃ³rico desde tabla inventar ---
    const inv: any = (DATA_SOURCES as any).inventar;
    const invResolved = await resolveTable(inv.table, inv.schema);
    if (!invResolved.schema) return res.status(404).json({ error: "Tabla inventar no encontrada" });

    const invCode       = safeIdent(inv.code);
    const invStockUnits = safeIdent(inv.stock_units ?? "stocdisp");
    const invQtyPerBox  = safeIdent(inv.qty_per_box ?? "cantcaja");
    if (!invCode) return res.status(500).json({ error: "Columna code en inventar no detectada" });

    const sqlInv =
      'SELECT ' +
      (invStockUnits ? `i.${q(invStockUnits)}::numeric` : 'NULL::numeric') + ' AS stock_units, ' +
      (invQtyPerBox  ? `i.${q(invQtyPerBox )}::numeric` : 'NULL::numeric') + ' AS qty_per_box ' +
      `FROM "${invResolved.schema}"."${invResolved.table}" i ` +
      `WHERE i.${q(invCode)} = $1 LIMIT 1`;

    const invRow = (await pool.query(sqlInv, [productCode])).rows[0] ?? { stock_units: null, qty_per_box: null };
    const inventory_boxes =
      invRow && invRow.qty_per_box && Number(invRow.qty_per_box) > 0
        ? Number(invRow.stock_units || 0) / Number(invRow.qty_per_box)
        : 0;

    // --- Conteo fÃ­sico desde app_physical_count (Ãºltimo por ubicaciÃ³n) ---
    const pcName = (await findColumnName("app_physical_count", ["productCode","productcode"])) ?? "productCode";
    const caName = (await findColumnName("app_physical_count", ["countedAt","countedat"])) ?? "countedAt";
    const cbName = (await findColumnName("app_physical_count", ["countedBoxes","countedboxes"])) ?? "countedBoxes";

    const colPC = `c.${q(pcName)}`;
    const colCA = `c.${q(caName)}`;
    const colCB = `c.${q(cbName)}`;

    const sqlPhys =
      `WITH ranked AS (
         SELECT c.*, ROW_NUMBER() OVER (PARTITION BY c.location_id ORDER BY ${colCA} DESC, c."id" DESC) rn
           FROM app_physical_count c
          WHERE ${colPC} = $1
       )
       SELECT COALESCE(SUM(${colCB}),0)::numeric AS physical_boxes
         FROM ranked
        WHERE rn = 1`;

    const physRow = (await pool.query(sqlPhys, [productCode])).rows[0] ?? { physical_boxes: 0 };
    const physical_boxes = Number(physRow.physical_boxes || 0);

    const diff = physical_boxes - inventory_boxes;
    const diffPct = inventory_boxes > 0 ? (diff / inventory_boxes) * 100 : 0;

    res.json({
      productCode,
      inventory_boxes: Number(inventory_boxes.toFixed(6)),
      physical_boxes: Number(physical_boxes.toFixed(6)),
      difference_boxes: Number(diff.toFixed(6)),
      difference_percent: Number(diffPct.toFixed(2)),
    });
  } catch (e: any) {
    res.status(500).json({ error: e.message || "summary error" });
  }
});
export default router;